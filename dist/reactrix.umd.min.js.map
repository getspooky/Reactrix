{"version":3,"file":"reactrix.umd.min.js","sources":["../src/utils/types.js","../src/common.js","../src/useValidate.js"],"sourcesContent":["// Copyright 2020 the Reactrix authors. All rights reserved. MIT license.\n\n// Check if given argument is null or undefined.\nexport function isNullOrUndefined(value) {\n  return value === null || value === undefined;\n}\n\n// Check if given argument is an empty array.\nexport function isEmptyArray(arr) {\n  return Array.isArray(arr) && arr.length === 0;\n}\n\n// Check if given argument is an object.\nexport const isObject = (obj) =>\n  obj !== null && obj && typeof obj === 'object' && !Array.isArray(obj);\n\n// Check if given argument is a callback function.\nexport function isCallable(fn) {\n  return typeof fn === 'function';\n}\n\n// Check if given argument is a string.\nexport function isString(arr) {\n  return typeof arr === 'string';\n}\n\n// Check if given object has own property.\nexport function isHasOwnProperty(obj, key) {\n  return isObject(obj) && obj.hasOwnProperty(key);\n}\n","// Copyright 2020 the Reactrix authors. All rights reserved. MIT license.\nimport { isHasOwnProperty, isString } from './utils/types';\n\n// Import rules from given path.\nfunction lazy(alias) {\n  const { rules } = require('../config/register-rules.json');\n  if(!rules.hasOwnProperty(alias)) {\n    throw new TypeError(`No such validator '${alias}' exists.`);\n  }\n  const realPath = new String(rules[alias])\n                  .replace('root:', './');\n  return require(realPath);\n}\n\n// validate given input.\nexport function validateRules(input, rules, language = 'en') {\n\n  if(!isHasOwnProperty(input, 'fieldKey')) {\n    input = { fieldKey: 'V' , fieldVal: input };\n  }\n\n  const { fieldKey, fieldVal } = input;\n\n  // list of errors provied by Reactrix.\n  const stackError = [];\n\n  if (!isString(rules)) {\n    throw new TypeError('Rule must be string (see docs)');\n  }\n  // check if the given rule has a value\n  const splitPipe = rules.split('|');\n  // push errors.\n  splitPipe.forEach(rule => {\n      const getRuleExp = lazy(rule);\n      //\n      if(!getRuleExp.default(fieldVal)) {\n        const msgError = getTranslator(rule, language)\n                         .replace('{{input}}', fieldKey);\n        stackError.push(msgError);\n      }\n  });\n\n  return stackError;\n\n}\n\n// translate given validator.\nfunction getTranslator(rule, currentLng) {\n  const { lang } = require('../config/register-lang.json');\n  if(!lang.hasOwnProperty(currentLng)) {\n    throw new TypeError(`Reactrix does not support ${currentLng} yet`);\n  }\n  const { messages } = require(`../locale/${lang[currentLng]}`);\n  return new String(messages[rule]);\n}\n\n// return the error length.\nexport function getStackError(stackError) {\n  return stackError.length;\n}\n\n// example: min:39, max:20.\nexport function hasValue(arr) {\n  return arr.indexOf(':') !== -1;\n}\n\nexport const regex = (type, expr) => (value) => {\n  return expr.test(value);\n}\n\nexport const assertExp = (type, cb) => (value) => {\n  return cb(value);\n};\n","// Copyright 2020 the Reactrix authors. All rights reserved. MIT license.\nimport React, { useState } from 'react';\nimport { validateRules } from './common';\nimport { isObject, isNullOrUndefined } from './utils/types';\n\nexport function useValidate(defaultLanguage = 'en') {\n\n   const [msg, setMsg] = useState([]);\n\n   const setValidator = (data, rules) => {\n\n     if(!isObject(rules) || isNullOrUndefined(rules)) {\n       throw new TypeError('Rules has to return an object (see docs)');\n     }\n\n     // Starts the validation process.\n     for (const [key, value] of Object.entries(rules)) {\n        const message = validateRules(data[key], value, defaultLanguage);\n        // push message state.\n        setMsg(previousState => [...previousState,...message]);\n     }\n\n   };\n\n   return [ msg, setValidator ];\n\n}\n"],"names":["isObject","obj","Array","isArray","validateRules","input","rules","language","key","hasOwnProperty","fieldKey","fieldVal","stackError","TypeError","split","forEach","rule","alias","require","realPath","String","replace","lazy","default","msgError","currentLng","lang","messages","getTranslator","push","defaultLanguage","useState","msg","setMsg","data","value","message","previousState","Object","entries"],"mappings":"mRAaO,IAAMA,EAAW,SAACC,UACf,OAARA,GAAgBA,GAAsB,iBAARA,IAAqBC,MAAMC,QAAQF,ICC5D,SAASG,EAAcC,EAAOC,EAAOC,GDYrC,IAA0BN,EAAKO,WCZMD,IAAAA,EAAW,MDYjBC,ECVR,WDWrBR,EADwBC,ECVVI,IDWGJ,EAAIQ,eAAeD,KCVzCH,EAAQ,CAAEK,SAAU,IAAMC,SAAUN,UAGPA,EAAvBK,IAAAA,SAAUC,IAAAA,SAGZC,EAAa,MDDG,iBCGRN,QACN,IAAIO,UAAU,yCAGJP,EAAMQ,MAAM,KAEpBC,SAAQ,SAAAC,OA5BpB,SAAcC,OACJX,EAAUY,QAAQ,iCAAlBZ,UACJA,EAAMG,eAAeQ,SACjB,IAAIJ,gCAAgCI,mBAEtCE,EAAW,IAAIC,OAAOd,EAAMW,IACjBI,QAAQ,QAAS,aAC3BH,QAAQC,GAsBQG,CAAKN,GAETO,QAAQZ,GAAW,KAC1Ba,EAWd,SAAuBR,EAAMS,OACnBC,EAASR,QAAQ,gCAAjBQ,SACJA,EAAKjB,eAAegB,SAChB,IAAIZ,uCAAuCY,cAE3CE,EAAaT,qBAAqBQ,EAAKD,IAAvCE,gBACD,IAAIP,OAAOO,EAASX,IAjBJY,CAAcZ,EAAMT,GACnBc,QAAQ,YAAaX,GACvCE,EAAWiB,KAAKL,OAIfZ,gBCrCF,SAAqBkB,YAAAA,IAAAA,EAAkB,YAErBC,WAAS,IAAxBC,OAAKC,aAiBL,CAAED,EAfY,SAACE,EAAM5B,OAEtBN,EAASM,IFPT6B,MEOqC7B,QACjC,IAAIO,UAAU,gDFTpB,4BEaUL,OAAK2B,OACRC,EAAUhC,EAAc8B,EAAK1B,GAAM2B,EAAOL,GAEhDG,GAAO,SAAAI,mBAAqBA,EAAiBD,aAHrBE,OAAOC,QAAQjC"}